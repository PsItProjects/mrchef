name: iOS - Build & Upload to TestFlight

on:
  push:
    branches: ["main", "master"]
  workflow_dispatch:

concurrency:
  group: ios-testflight-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build_upload:
    runs-on: macos-14
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare .env (CI)
        env:
          DOTENV_FILE_BASE64: ${{ secrets.DOTENV_FILE_BASE64 }}
        run: |
          set -euo pipefail
          # The Flutter app includes `.env` as an asset. In CI the file is typically not committed.
          # We create it here to prevent: "No file or variants found for asset: .env".
          if [[ -n "${DOTENV_FILE_BASE64:-}" ]]; then
            echo "$DOTENV_FILE_BASE64" | base64 -D > .env
          elif [[ -f .env.example ]]; then
            cp .env.example .env
          else
            printf "# Generated by GitHub Actions\n" > .env
          fi
          ls -l .env

      - name: Setup Firebase GoogleService-Info.plist (iOS)
        env:
          GOOGLE_SERVICE_INFO_PLIST_BASE64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_BASE64 }}
        run: |
          set -euo pipefail
          # GoogleService-Info.plist is required for Firebase/FCM to work
          if [[ -n "${GOOGLE_SERVICE_INFO_PLIST_BASE64:-}" ]]; then
            echo "Setting up GoogleService-Info.plist from secret..."
            echo "$GOOGLE_SERVICE_INFO_PLIST_BASE64" | base64 -D > ios/Runner/GoogleService-Info.plist
            echo "✅ GoogleService-Info.plist created"
          elif [[ -f ios/Runner/GoogleService-Info.plist ]]; then
            echo "✅ GoogleService-Info.plist already exists in repository"
          else
            echo "⚠️ WARNING: GoogleService-Info.plist not found!"
            echo "Firebase/FCM push notifications will NOT work without this file."
            echo "Please add GOOGLE_SERVICE_INFO_PLIST_BASE64 secret or commit the file."
          fi
          ls -l ios/Runner/GoogleService-Info.plist 2>/dev/null || true

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          # Ensure the runner uses a recent Swift toolchain (some Pods require newer Swift keywords).
          xcode-version: latest-stable

      - name: Xcode & Swift versions
        run: |
          set -euo pipefail
          xcodebuild -version
          swiftc --version

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          # Pin Flutter version to avoid CI failures resolving "stable" on macos-14 (arm64)
          flutter-version: "3.29.0"
          cache: true

      - name: Flutter pub get
        run: flutter pub get

      - name: Install CocoaPods
        run: |
          set -euo pipefail
          cd ios
          pod install --repo-update

      - name: Validate required secrets
        env:
          APPSTORE_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}
          APPSTORE_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
          APPSTORE_KEY_P8: ${{ secrets.APPSTORE_KEY_P8_BASE64 }}
          IOS_DIST_CERT_P12_BASE64: ${{ secrets.IOS_DIST_CERT_P12_BASE64 }}
          IOS_DIST_CERT_PASSWORD: ${{ secrets.IOS_DIST_CERT_PASSWORD }}
          IOS_PROVISION_PROFILE_BASE64: ${{ secrets.IOS_PROVISION_PROFILE_BASE64 }}
        run: |
          set -euo pipefail
          for v in APPSTORE_KEY_ID APPSTORE_ISSUER_ID APPSTORE_KEY_P8 IOS_DIST_CERT_P12_BASE64 IOS_DIST_CERT_PASSWORD IOS_PROVISION_PROFILE_BASE64; do
            if [[ -z "${!v:-}" ]]; then
              echo "Missing required secret: $v" >&2
              exit 1
            fi
          done

      - name: Install signing certificate & provisioning profile
        env:
          IOS_DIST_CERT_P12_BASE64: ${{ secrets.IOS_DIST_CERT_P12_BASE64 }}
          IOS_DIST_CERT_PASSWORD: ${{ secrets.IOS_DIST_CERT_PASSWORD }}
          IOS_PROVISION_PROFILE_BASE64: ${{ secrets.IOS_PROVISION_PROFILE_BASE64 }}
        run: |
          set -euo pipefail

          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain-db
          KEYCHAIN_PASSWORD="${KEYCHAIN_PASSWORD:-temp_password}"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "$IOS_DIST_CERT_P12_BASE64" | base64 -D > $RUNNER_TEMP/ios_dist.p12
          ls -l $RUNNER_TEMP/ios_dist.p12

          # Sanity check: ensure the decoded P12 matches the provided password.
          if ! openssl pkcs12 -info -in $RUNNER_TEMP/ios_dist.p12 -noout -passin "pass:$IOS_DIST_CERT_PASSWORD" >/dev/null 2>&1; then
            echo "P12 sanity check failed: password mismatch or corrupted P12" >&2
            exit 1
          fi
          shasum -a 256 $RUNNER_TEMP/ios_dist.p12

          # Some macOS runner images fail to import newer OpenSSL-generated PKCS#12 (PBES2/SHA256)
          # via `security import` even when the password is correct.
          # Workaround: extract cert+key with OpenSSL (already validated above), then import PEMs.
          openssl pkcs12 -in $RUNNER_TEMP/ios_dist.p12 -clcerts -nokeys -passin "pass:$IOS_DIST_CERT_PASSWORD" -out $RUNNER_TEMP/ios_dist_cert.pem
          openssl pkcs12 -in $RUNNER_TEMP/ios_dist.p12 -nocerts -nodes -passin "pass:$IOS_DIST_CERT_PASSWORD" -out $RUNNER_TEMP/ios_dist_key.pem

          if ! security import $RUNNER_TEMP/ios_dist_cert.pem -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security; then
            echo "Failed to import signing certificate into keychain." >&2
            exit 1
          fi
          if ! security import $RUNNER_TEMP/ios_dist_key.pem -k "$KEYCHAIN_PATH" -P "" -T /usr/bin/codesign -T /usr/bin/security; then
            echo "Failed to import signing private key into keychain." >&2
            exit 1
          fi
          rm -f $RUNNER_TEMP/ios_dist_key.pem $RUNNER_TEMP/ios_dist_cert.pem

          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "$IOS_PROVISION_PROFILE_BASE64" | base64 -D > $RUNNER_TEMP/profile.mobileprovision
          UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< "$(security cms -D -i $RUNNER_TEMP/profile.mobileprovision)")
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          cp $RUNNER_TEMP/profile.mobileprovision "$HOME/Library/MobileDevice/Provisioning Profiles/$UUID.mobileprovision"

      - name: Build iOS Archive (Release)
        run: |
          set -euo pipefail
          VERSION_LINE=$(grep '^version:' pubspec.yaml | awk '{print $2}')
          BUILD_NAME=${VERSION_LINE%%+*}
          if [[ "$VERSION_LINE" == *"+"* ]]; then
            BASE_NUMBER=${VERSION_LINE#*+}
          else
            BASE_NUMBER=0
          fi
          BUILD_NUMBER=$((BASE_NUMBER + GITHUB_RUN_NUMBER))
          echo "Using build-name=$BUILD_NAME build-number=$BUILD_NUMBER"

          # Build the Flutter iOS app (release mode) without code signing first
          flutter build ios --release --no-codesign --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"

          # Archive with xcodebuild (this ensures proper signing)
          cd ios
          xcodebuild archive \
            -workspace Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -archivePath $RUNNER_TEMP/Runner.xcarchive \
            -destination 'generic/platform=iOS' \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            DEVELOPMENT_TEAM="HV9C8SYRKZ" \
            -allowProvisioningUpdates

      - name: Export IPA for App Store
        run: |
          set -euo pipefail
          # Create ExportOptions.plist using printf (heredoc breaks YAML indentation)
          printf '%s\n' \
            '<?xml version="1.0" encoding="UTF-8"?>' \
            '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' \
            '<plist version="1.0">' \
            '<dict>' \
            '    <key>method</key>' \
            '    <string>app-store-connect</string>' \
            '    <key>teamID</key>' \
            '    <string>HV9C8SYRKZ</string>' \
            '    <key>uploadSymbols</key>' \
            '    <true/>' \
            '    <key>signingStyle</key>' \
            '    <string>manual</string>' \
            '    <key>provisioningProfiles</key>' \
            '    <dict>' \
            '        <key>com.mrchef.app</key>' \
            '        <string>Mr.Chef</string>' \
            '    </dict>' \
            '</dict>' \
            '</plist>' > $RUNNER_TEMP/ExportOptions.plist
          echo "=== ExportOptions.plist ==="
          cat $RUNNER_TEMP/ExportOptions.plist
          # Export IPA
          mkdir -p build/ios/ipa
          xcodebuild -exportArchive \
            -archivePath $RUNNER_TEMP/Runner.xcarchive \
            -exportPath build/ios/ipa \
            -exportOptionsPlist $RUNNER_TEMP/ExportOptions.plist
          ls -la build/ios/ipa/

      - name: Resolve IPA path
        id: ipa
        run: |
          set -euo pipefail
          IPA_PATH=$(ls build/ios/ipa/*.ipa 2>/dev/null | head -n 1 || true)
          if [[ -z "$IPA_PATH" ]]; then
            echo "ERROR: No IPA file found in build/ios/ipa/"
            ls -laR build/ios/ || true
            exit 1
          fi
          echo "ipa_path=$IPA_PATH" >> "$GITHUB_OUTPUT"
          echo "IPA: $IPA_PATH"

      - name: Decode App Store Connect API key (p8)
        id: asc
        env:
          APPSTORE_KEY_P8: ${{ secrets.APPSTORE_KEY_P8_BASE64 }}
        run: |
          set -euo pipefail
          # Check if the secret is raw PEM or Base64 encoded
          if echo "$APPSTORE_KEY_P8" | grep -q "BEGIN PRIVATE KEY"; then
            # Already raw PEM format
            DECODED_KEY="$APPSTORE_KEY_P8"
            echo "API Key is in raw PEM format"
          else
            # Base64 encoded - decode it
            DECODED_KEY=$(echo "$APPSTORE_KEY_P8" | base64 -D)
            echo "API Key decoded from Base64"
          fi
          # Validate the key looks correct
          if ! echo "$DECODED_KEY" | grep -q "BEGIN PRIVATE KEY"; then
            echo "ERROR: API Key does not contain valid PEM header" >&2
            exit 1
          fi
          # Output the key for the next step
          echo "api_private_key<<EOF" >> "$GITHUB_OUTPUT"
          printf '%s\n' "$DECODED_KEY" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Upload app to TestFlight
        uses: apple-actions/upload-testflight-build@v3
        with:
          app-path: ${{ steps.ipa.outputs.ipa_path }}
          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_KEY_ID }}
          api-private-key: ${{ steps.asc.outputs.api_private_key }}

      - name: Upload build artifact (IPA)
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa
          path: build/ios/ipa/*.ipa
          retention-days: 14
